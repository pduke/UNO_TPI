//// UNO_TPI.c - TPI (Tiny Programming Interface) programmer// - An AVR910 programmer that handles newer chips, minor//   modifications to avrdude configuration is required.// - High Voltage (+12v) programming for ATtiny4/5/9/10// - Now runs on Arduino UNO//// v1.0 - Original version based on AVR_ISP.c, an avr910 type programmer,//				for a standalone ATmega328p chip//				by Paul Duke	2013// v1.1 - Move to Arduino UNO, Use SPI for serial TPI comm//				Add error LED, ready LED, button and reset capacitor//				by Paul Duke 2016///************************************************** * TPI programmer for ATtiny4/5/9/10/20/40 * * Make the connections as shown below. * *-- The only pin that really needs a resistor is 11 * * Arduino                 ATtiny10               * * ----------+          +----------------         * * (SS#)  10 |--[R]-----| 6 (RESET#/PB3)          * *           |          |                         * * (MOSI) 11 |--[R]--+--| 1 (TPIDATA/PB0)         * *           |       |  |                         * * (MISO) 12 |--[R]--+  |                         * *           |          |                         * * (SCK)  13 |--[R]-----| 3 (TPICLK/PB1)          * * ----------+          +----------------         * *                                                * * ----------+          +----------------         * * (HVP)   9 |---       | 6 (RESET#/PB3)          * *           |          |                         * *                                                * *  -[R]-  =  a few kOhm resistor                 * *                                                * ***************************************************/#include <avr/interrupt.h>#include <stdbool.h>#include <avr/pgmspace.h>#include <util/delay.h>#include "uart.c"#include "pin_io_macros.c"// define ports, pins // (Arduino UNO)//#define TPI_RESET		B,2		// (D10)#define MOSI 				B,3		// (D11)#define MISO 				B,4		// (D12)#define SCK 				B,5		// (D13)#define READY_LED		C,5		// (A5)#define ERROR_LED		C,4		// (A4)#define RESET_CAP	  C,0		// (A0)#define BUTTON			C,1		// (A1)#define YES 1#define NO 0#if LCD_4BIT == YES	// override standard lcd pin assignments 	//	#define __LCD_PIN_OVERRIDE__	#define LCD_RS		B,0		// (D8) Register Select	#define LCD_RW		D,7		// (D7) Read/Write	#define LCD_E			D,6		// (D6) Enable data transfer	#define LCD_DB4		D,5		// (D5) Data bits ...	#define LCD_DB5		D,4		// (D4)	#define LCD_DB6		D,3		// (D3)	#define LCD_DB7		D,2		// (D2) also Ready/Busy flag	#include "lcd_4_bit.c" // include lcd header now that pin overrides are defined#endif// TPI KEY #define NVM_PROGRAM_ENABLE 0x1289AB45CDD888FFvolatile bool in_programming_mode = false;// TPI Instruction Set#define SLD						0b00100000#define SLD_POSTINC		0b00100100#define SST						0b01100000#define SST_POSTINC		0b01100100#define SSTPR					0b01101000#define SIN						0b00010000#define SOUT					0b10010000#define SLDCS					0b10000000#define SSTCS					0b11000000#define SKEY					0b11100000// TPI Control and Status Registers#define TPISR					0b00000000#define TPIPCR				0b00000010#define TPIIR					0b00001111// TIPSR bits#define NVMEM					0b00000010// NVM Commands#define NVMCMD_NO_OPERATION		0x00#define NVMCMD_CHIP_ERASE			0x10#define NVMCMD_SECTION_ERASE	0x14#define NVMCMD_MEMORY_WRITE		0x1D#define words_to_write 	1// register addresss#define NVMCSR 0X32#define NVMCMD 0X33// Memory space definitions#define IO_SPACE_START						0x0000#define IO_SPACE_END							0x003F	#define SRAM_DATA_MEMORY_START		0x0040 #define SRAM_DATA_MEMORY_END			0x005F	#define NVM_LOCK_BITS_START				0x3F00#define NVM_LOCK_BITS_SIZE				2#define CONF_BITS_START						0x3F40#define CONF_BITS_SIZE						2#define CALIB_BITS_START					0x3F80 #define CALIB_BITS_SIZE						2#define DEV_ID_START							0x3FC0#define DEV_ID_SIZE								3 #define NVM_PROG_MEM_START				0x4000#define NVM_PROG_MEM_END					0x43FF#define GUARD_TIME_128						0#define GUARD_TIME_64							1#define GUARD_TIME_32							2#define GUARD_TIME_16							3#define GUARD_TIME_8							4#define GUARD_TIME_4							5#define GUARD_TIME_2							6#define GUARD_TIME_0							7// tpi variables/values/macros#define TPI_OK					0#define TPI_TIMEOUT		1#define TPI_ERROR			2#define MEMORY_TYPE_FLASH 'F'#define MEMORY_TYPE_EEPROM 'E'#define SIG_LEN 3uint8_t AVR_Signature[SIG_LEN];uint16_t total_bytes_written;uint16_t total_bytes_read;// error handling#define READ_TIMEOUT_MS 			100uint8_t error;#define ERROR_TPI_READ_TIMEOUT		1#define ERROR_TPI_NVM_TIMEOUT			2// TPI/AVR variables/values/macros//uint16_t address;uint16_t byte_count;uint8_t memory_type;// UART specific - ring buffer//#define Q_SIZE 128volatile uint8_t q_buff[Q_SIZE];volatile uint8_t qin;volatile uint8_t qout;// programmer info//#define PROGRAMMER_ID		"UNO_TPI"#define HARDWARE_VERSION 	"10"#define SOFTWARE_VERSION	"10"// Supported Devices typedef struct {	char			name[10];	uint8_t		signature[SIG_LEN];	uint8_t		device_code;	uint16_t	flash_offset;		uint16_t	page_size;	uint16_t	page_count;}	AVR_DEVICE;AVR_DEVICE target_avr;uint8_t AVR_Signature[3];#define DEVICE_COUNT 4const AVR_DEVICE	avr_info[DEVICE_COUNT] PROGMEM =	{													{	"ATtiny4",														"\x1E\x8F\x0A",														0x04,														0x4000,														8,														32													},													{	"ATtiny5",														"\x1E\x8F\x09",														0x05,														0x4000,														8,														32													},													{	"ATtiny9",														"\x1E\x90\x08",														0x09,														0x4000,														8,														64													},													{	"ATtiny10",														"\x1E\x90\x03",														0x10,														0x4000,														8,														64													}												};// ms timer interruptvolatile uint32_t msNow;uint32_t msBlinkStamp;ISR(TIMER2_COMPA_vect, ISR_NOBLOCK){	msNow++;		// increment the counter	if(in_programming_mode){		if(msNow - msBlinkStamp > 50){		// blink delay ms			msBlinkStamp = msNow;			TOGGLE(READY_LED);		}	}}// LCD stream file - enable printf in functions outside of main()FILE lcd_stream;// --------------------------------------------------------------------------------------// the ring buffer is filled by the usart interrupt routine and// whenever the index's don't match there is data in the buffer.// Othewise hang and wait for data. No flow control exists so// the buffer must be large enough to handle incoming data or// it will wrap and overwrite. For us this is page size plus// a few bytes.uint8_t uart_read_q(void){	uint8_t data;	while(qout==qin);	data=q_buff[qout++];	if(qout==Q_SIZE) qout=0;	return(data);}// get the incoming character and put it in the bufferISR(USART_RX_vect, ISR_BLOCK){	q_buff[qin++]=UDR0;	if(qin==Q_SIZE) qin=0;}void uart_writeX(char x) {		// wait for empty receive buffer		while ((UCSR0A & (1<<UDRE0))==0);		// send		UDR0 = x;	}// simply send a flash const string to avrdudevoid uart_write_PSTR(const char *data){	int i;	for(i=0;pgm_read_byte_near((char*)&data[i]);i++)		uart_writeX(pgm_read_byte_near((char*)&data[i]));}uint8_t spi_transfer(uint8_t send){	SPDR = send;	while(!(SPSR & _BV(SPIF)));	return(SPDR);}// SPI code comes from http://junkplusarduino.blogspot.jp/p/attiny10-resources.html// send a byte in one TPI frame (12 bits)// (1 start + 8 data + 1 parity + 2 stop)// using 2 SPI data bytes (2 x 8 = 16 clocks)// (with 4 extra idle bits)void write_tpi(uint8_t data){	if(error) return;  // compute partiy bit  uint8_t par = data;  par ^= (par >> 4); // b[7:4] (+) b[3:0]  par ^= (par >> 2); // b[3:2] (+) b[1:0]  par ^= (par >> 1); // b[1] (+) b[0]  // REMEMBER: this is in LSBfirst mode and idle is high  // (2 idle) + (1 start bit) + (data[4:0])  spi_transfer(0x03 | (data << 3));  // (data[7:5]) + (1 parity) + (2 stop bits) + (2 idle)  spi_transfer(0xf0 | (par << 3) | (data >> 5));}// receive TPI 12-bit format byte data// via SPI 2 bytes (16 clocks) or 3 bytes (24 clocks)uint8_t read_tpi( void ){	if(error) return(0);	uint32_t readTimeStamp = msNow;  uint8_t b1, b2;  // keep transmitting high(idle) while waiting for a start bit  do {		if(msNow - readTimeStamp > READ_TIMEOUT_MS){			error = ERROR_TPI_READ_TIMEOUT;			SET(ERROR_LED);			return(0);		}    b1 = spi_transfer(0xff);  } while (b1 == 0xff);  // get (partial) data bits  b2 = spi_transfer(0xff);  // if the first byte(b1) contains less than 4 data bits  // we need to get a third byte to get the parity and stop bits  if (0x0f == (0x0f & b1)) {    spi_transfer(0xff);  }  // now shift the bits into the right positions  // b1 should hold only idle and start bits = 0b01111111  while (0x7f != b1) { // data not aligned    b2 <<= 1; // shift left data bits    if (0x80 & b1) { // carry from 1st byte      b2 |= 1; // set bit    }    b1 <<= 1;    b1 |= 0x01; // fill with idle bit (1)  }  // now the data byte is stored in b2  return( b2 );}// Send NVM Command to be exectued via TPIvoid write_nvm_command(uint8_t nvm_command){	write_tpi(SOUT | ((NVMCMD & 0XF0)<<1) | (NVMCMD & 0X0F));	write_tpi(nvm_command);}// Send address of the NVM location to be accessed via TPIvoid write_nvm_address(volatile uint16_t nvm_address){	write_tpi(SSTPR);//Address Low Byte	write_tpi(((uint8_t)nvm_address & 0x00FF));	write_tpi(SSTPR | 0X01);//Address High Byte	write_tpi((uint8_t)(nvm_address >>8));}// Read one byte from NVM via TPIuint8_t read_nvm_byte(void){	write_tpi(SLD_POSTINC);	return read_tpi();}// Write whole word to NVM  via TPIvoid write_nvm_word(volatile uint16_t data){	write_tpi(SST_POSTINC);	write_tpi(data & 0X00FF); // low byte	write_tpi(SST_POSTINC);	write_tpi(data >> 8); // high byte}// Check if NVM is busy by reading NVMCSRbool nvm_busy(void){	write_tpi(SIN |((NVMCSR & 0XF0)<<1) | (NVMCSR & 0X0F));	if(read_tpi() == 0x80) return true;	return false;}// get the signature from the target device and load related info for the target.// signature is 3 bytes read 1 at a time. The use to lookup dev info in tableuint8_t tpi_enter_programming_mode(void);uint8_t get_signature(void){		tpi_enter_programming_mode();		write_nvm_command(NVMCMD_MEMORY_WRITE);		write_nvm_address(DEV_ID_START);		for(uint8_t i=0; i<SIG_LEN; i++){			AVR_Signature[i] = read_nvm_byte();		}		for(uint8_t i=0;i<DEVICE_COUNT;i++){			if(!memcmp_P(AVR_Signature,avr_info[i].signature,SIG_LEN)){				for(uint8_t j=0;j<sizeof(AVR_DEVICE);j++)					((char*)&target_avr)[j] = pgm_read_byte_near(&((char*)&avr_info[i])[j]);				return(TPI_OK);			}		}	return(TPI_ERROR);}// void tpi_leave_programming_mode(void){	in_programming_mode = false;	SET(READY_LED);	// disable NVM programming	write_tpi(SSTCS | TPISR);	write_tpi(0);	_delay_ms(10);	// disable spi and set pins tri-state	SPCR = 0;	PULLUP_OFF(SCK);	PULLUP_OFF(MOSI);	PULLUP_OFF(MISO);	// reset target mcu	CLEAR(TPI_RESET);	_delay_ms(10);}// send 2 breaks over tpivoid sendBreaks(void){	SPCR = 0;						// disable spi 	OUTPUT(SCK);				// but set up ports	OUTPUT(MOSI);				// so we can bit bang	PULLUP_OFF(MISO);		// a couple of break characters	uint8_t i;	SET(SCK);	CLEAR(MOSI);	for(i=0;i<12;i++){	// 12 bits in a break		_delay_ms(1);		CLEAR(SCK);		_delay_ms(1);		SET(SCK);	}	_delay_ms(1);	SET(MOSI);					// separate breaks	_delay_ms(2);	CLEAR(MOSI);	for(i=0;i<12;i++){	// second 12 bits for a break char		_delay_ms(1);		CLEAR(SCK);		_delay_ms(1);		SET(SCK);	}	_delay_ms(1);	SET(MOSI);	_delay_ms(2);	PULLUP_OFF(SCK);	PULLUP_OFF(MOSI);}// enter programming mode and set guard timeuint8_t tpi_enter_programming_mode(void){	if(!in_programming_mode){		// reset error status		CLEAR(ERROR_LED);		error = 0;		// power to TPI_RESET 		OUTPUT(TPI_RESET);		// this puts the chip in programming mode		// either pull down reset or enable the 12v supply		SET(TPI_RESET);		_delay_ms(10); // give time for 12v rise for Max662 or similar		// send a couple of breaks to sync with target chip		sendBreaks();		// set up spi		OUTPUT(SCK);		OUTPUT(MOSI);		PULLUP_OFF(MISO);		SPCR = _BV(SPE) | _BV(DORD) | _BV(MSTR) | _BV(SPR0);	// DIV8, 2MHz clock, tiny10 max		SPSR = _BV(SPI2X);    // enter TPI programming mode    _delay_ms(1); // t_RST min = 400 ns @ Vcc = 5 V		spi_transfer(0xff); // activate TPI by emitting		spi_transfer(0xff); // 16 or more pulses on TPICLK		spi_transfer(0xff); // while holding TPIDATA to "1"		// enable programming with key value		uint64_t key = NVM_PROGRAM_ENABLE;		write_tpi(SKEY);		for(int8_t i=0;i<8;i++){			write_tpi(key & 0xFF);			key >>= 8;		}		// wait for NVMEM to be set in TPISR		uint8_t enabled = 0;		uint8_t nvmemTries = 0;		while(enabled==0 && error == 0){			if(nvmemTries++ > 100){				error = ERROR_TPI_NVM_TIMEOUT;				SET(ERROR_LED);				break;			}			write_tpi(SLDCS | TPISR);		 	enabled = read_tpi() & NVMEM;		}		if(error == 0){			// set guard time			write_tpi(SSTCS | TPIPCR);			write_tpi(GUARD_TIME_2);			in_programming_mode = true;		} else {			tpi_leave_programming_mode();		}	}	return(TPI_OK);}// routines to process universal commands from avrdudeuint8_t universal_read_fuse(uint16_t address){	uart_read_q();	uart_read_q();	write_nvm_address(address);	uint8_t value = read_nvm_byte();	uart_writeX(value);	uart_writeX('\r');	return value;}void universal_write_fuse(uint16_t address, uint8_t value){//	uart_read_q();	// erase first	write_nvm_command((uint8_t)NVMCMD_SECTION_ERASE);	write_nvm_address(address);	write_nvm_word(0xFFFF);	while(nvm_busy());	// then write new value	write_nvm_command(NVMCMD_MEMORY_WRITE);	write_nvm_address(address);	write_nvm_word(0xFF00 | value);	while(nvm_busy());	uart_writeX(0x00);	uart_writeX('\r');}// --------------------------------------------------------------------------------------------------------int main() {#if LCD_4BIT == YES	// initialize LCD display	lcd_init(4, 20);	fdev_setup_stream(&lcd_stream, lcd_putchar, 0, _FDEV_SETUP_WRITE); 	fprintf_P(&lcd_stream, PSTR("UNO_TPI v1.1")); #endif	// initialize uart, set baudrate, and enable rx interrupts#if F_CPU == 16000000	uart_init();	#if BAUD == 2400		UBRR0L = 832;			UCSR0A = _BV(U2X0);	#elif BAUD == 4800		UBRR0L = 416;			UCSR0A = _BV(U2X0);	#elif BAUD == 9600		UBRR0L = 103;			UCSR0A = 0;	#elif BAUD == 14400		UBRR0L = 138;			UCSR0A = _BV(U2X0);	#elif BAUD == 19200		UBRR0L = 51;			UCSR0A = 0;	#elif BAUD == 28800		UBRR0L = 68;			UCSR0A = _BV(U2X0);	#elif BAUD == 38400		UBRR0L = 25;			UCSR0A = 0;	#elif BAUD == 57600		UBRR0L = 34;			UCSR0A = _BV(U2X0);	#elif BAUD == 76800		UBRR0L = 12;			UCSR0A = 0;	#elif BAUD == 115200		UBRR0L = 16;			UCSR0A = _BV(U2X0);	#elif BAUD == 230400		UBRR0L = 8;			UCSR0A = _BV(U2X0);	#elif BAUD == 250000		UBRR0L = 3;			UCSR0A = 0;	#elif BAUD == 500000		UBRR0L = 1;			UCSR0A = 0;	#elif BAUD == 1000000		UBRR0L = 0;			UCSR0A = 0;	#else		#error !BAUD value not supported by UNO_TPI.c	#endif	UCSR0B |= _BV(RXCIE0);		// enable receiver interrupt#else	#error !F_CPU value not supported by UNO_TPI.c#endif	// Start msTimer	TCCR2A = _BV(WGM21);						// CTC mode	TCCR2B = _BV(CS22) | _BV(CS20);	// clk/128 prescaling	OCR2A = 125;										// 16MHz/128/125 = 1ms	TIMSK2 = _BV(OCIE2A);						// enable interrupt// Set up ports	OUTPUT(READY_LED);	OUTPUT(ERROR_LED);	PULLUP_ON(BUTTON);							// toggle reset cap on/tri-state	OUTPUT(RESET_CAP);							// default state of reset capacitor is on	SET(RESET_CAP);									// which disables UNO reset thus UNO bootloader	SET(READY_LED);									// ready when reset cap is on	OUTPUT(TPI_RESET);							// HV programming pin	CLEAR(TPI_RESET);								// disable HV programming (12v)	// enable interrupts	sei();	// button debouncing states	#define IDLE 				0	#define PRESSED 		1	#define WAIT 				2	#define RELEASED 		3	// debouncing parameters	#define BOUNCE_PERIOD_MS 50	#define BUTTON_DOWN 			0	// debouncing variables	uint16_t msElapsed;																// elapsed time in ms	uint32_t msStamp = msNow;													// timestamp	uint8_t debouncing = IDLE;														// debounce flag	// process command variables	uint8_t save_byte=0;	uint8_t command;	uint16_t u_cmd;	uint8_t u_offset;	uint16_t byte_count=0;	uint8_t mem_type;	uint8_t fuse;	uint8_t lock;	while(true){		if(error && in_programming_mode){			tpi_leave_programming_mode();		// reset on error		}		if(qout!=qin){		// received character in queue?			command = uart_read_q();											//  Commands                           	| Host writes | Host reads |      |											//  --------                           	+-----+-------+------+-----+      |											//                                     	| ID  | data  | data |     | Note |			switch(command){				case 'P':			// | Enter programming mode            	| 'P' |       |      | 13d |   1  |					total_bytes_written = 0;					total_bytes_read = 0;					if(tpi_enter_programming_mode()==TPI_OK)						uart_writeX('\r');#if LCD_4BIT == YES						fprintf_P(&lcd_stream, PSTR("\n: prog %s"),target_avr.name); #endif					break;						case 'L':			// | Leave programming mode            	| 'L' |       |      | 13d |   5  |					tpi_leave_programming_mode();					uart_writeX('\r');#if LCD_4BIT == YES					fprintf_P(&lcd_stream, PSTR("\n: %d bytes"), total_bytes_written);#endif					break;						case 'a':			// | Report autoincrement address      	| 'a' |       | 	 | 'Y' |      |					uart_writeX('Y');					break;						case 'A':			// | Set address                       	| 'A' | ah al |      | 13d |   2  |					// word address for flash					address=(((uart_read_q()<<8)|uart_read_q())<<1)+target_avr.flash_offset;					write_nvm_address(address);					uart_writeX('\r');					break;						case 'c':			// | Write program memory, low byte    	| 'c' |    dd |      | 13d |   3  |					write_nvm_command(NVMCMD_MEMORY_WRITE);					write_tpi(SST_POSTINC);					write_tpi(uart_read_q());					uart_writeX('\r');#if LCD_4BIT == YES					if(total_bytes_written == 0) fprintf_P(&lcd_stream, PSTR("\n> "));					fprintf_P(&lcd_stream, PSTR("+"));#endif					total_bytes_written ++;					break;							case 'C':			// | Write program memory, high byte   	| 'C' |    dd |      | 13d |   3  |					write_tpi(SST_POSTINC);					write_tpi(uart_read_q());					address+=2; // auto-increment on high byte only					while(nvm_busy());					uart_writeX('\r');#if LCD_4BIT == YES					if(total_bytes_written == 0) fprintf_P(&lcd_stream, PSTR("\n> "));					fprintf_P(&lcd_stream, PSTR("+"));#endif					total_bytes_written ++;					break;						case 'R':			// | Read program memory               	| 'R' |       |dd(dd)|     |   4  |					write_nvm_command(NVMCMD_MEMORY_WRITE);					save_byte = read_nvm_byte(); 					uart_writeX(read_nvm_byte()); // high byte first					uart_writeX(save_byte); // then low byte					address+=2;  // auto-increment#if LCD_4BIT == YES					if(total_bytes_read == 0) fprintf_P(&lcd_stream, PSTR("\n< "));					fprintf_P(&lcd_stream, PSTR("-"));#endif					total_bytes_read += 2;				break;							case 'e':			// | Chip erase                        	| 'e' |       |      | 13d |      |					write_nvm_address(NVM_PROG_MEM_START);					write_nvm_command(NVMCMD_CHIP_ERASE);					write_nvm_word(0xFFFF);					while(nvm_busy());					uart_writeX('\r');#if LCD_4BIT == YES					fprintf_P(&lcd_stream, PSTR("\n> erase"), byte_count);#endif					break;						case 'b':   		// | check block support							| 'b' |       |dd dd |  Y  |      |					uart_writeX('Y');					if(get_signature()==TPI_OK){						uart_writeX((target_avr.page_count>>8)&0xFF);						uart_writeX(target_avr.page_count&0xFF);					}					break;				case 'B':	  		// | flash or eeprom block write		| 'B' |dd(dd) |      | 13d |      |					// get the byte count for this block					byte_count = ((uart_read_q()<<8) | uart_read_q());					// is it for flash or eeprom?					mem_type = uart_read_q();					if(mem_type == MEMORY_TYPE_FLASH){						write_nvm_command(NVMCMD_MEMORY_WRITE);						for(uint16_t i=0;i<byte_count;i+=2){							// write low byte							write_tpi(SST_POSTINC);							write_tpi(uart_read_q());							// write high byte							write_tpi(SST_POSTINC);							write_tpi(uart_read_q());							address++; // auto-increment on high byte only							while(nvm_busy());							}						}else{ 							// no eeprom on TPI tiny's, ignore							for(uint16_t i=0;i<byte_count;i++){								uart_read_q();							}						}					// tell host we're ready for next block					uart_write('\r');#if LCD_4BIT == YES					if(total_bytes_written == 0) fprintf_P(&lcd_stream, PSTR("\n> "));					fprintf_P(&lcd_stream, PSTR("+"));#endif					total_bytes_written += byte_count;					break;							case 'g':				// | flash or eeprom block read			| 'g' |       |dd(dd)|     |      |					// get byte count to read for this block					byte_count=(uart_read_q()<<8)|uart_read_q();					// get memory type - flash or eeprom					if(uart_read_q()==MEMORY_TYPE_FLASH){						write_nvm_command(NVMCMD_MEMORY_WRITE);						for(uint16_t i=0;i<byte_count;i+=2){							// read and send all the bytes for this block							uart_writeX(read_nvm_byte()); // low byte							uart_writeX(read_nvm_byte()); // high byte							// and auto-increment flash word address								address+=(byte_count>>1);						}#if LCD_4BIT == YES						if(total_bytes_read == 0) fprintf_P(&lcd_stream, PSTR("\n< "));						fprintf_P(&lcd_stream, PSTR("-"));#endif						total_bytes_read += byte_count;					}else{						// byte address given for eeprom						for(uint16_t i=0;i<byte_count;i++){							// no eeprom on TPI tiny's							uart_write(0x00);						}					}					break;				case 'f':			// | Write fuse bits                		| 'f' |    dd |      | 13d |  11  |					// erase first					write_nvm_command((uint8_t)NVMCMD_SECTION_ERASE);					write_nvm_address(CONF_BITS_START);					write_nvm_word(0xFFFF);					while(nvm_busy());					// then write new value					write_nvm_command(NVMCMD_MEMORY_WRITE);					write_nvm_address(CONF_BITS_START);					fuse = uart_read_q();					write_nvm_word(fuse);					while(nvm_busy());					uart_writeX('\r');#if LCD_4BIT == YES					fprintf_P(&lcd_stream, PSTR("\n> fuse %02X"), fuse);#endif					break;				case 'F':			// | Read fuse bits			      					| 'F' |       |   dd |     |  11  |					write_nvm_address(CONF_BITS_START);					uart_writeX(read_nvm_byte());					break;				case 'l':   		// | Write lock bits      						| 'l' |    dd |      | 13d |  14  |					// erase first					write_nvm_command((uint8_t)NVMCMD_SECTION_ERASE);					write_nvm_address(NVM_LOCK_BITS_START);					write_nvm_word(0xFFFF);					while(nvm_busy());					// then write new value					write_nvm_command(NVMCMD_MEMORY_WRITE);					write_nvm_address(NVM_LOCK_BITS_START);					lock = uart_read_q();					write_nvm_word(lock);					while(nvm_busy());					uart_writeX('\r');#if LCD_4BIT == YES					fprintf_P(&lcd_stream, PSTR("\n> lock %02X"), lock);#endif					break;									case 'r':   		// | Read lock bits										| 'r' |       |   dd |     |  14  |					write_nvm_address(NVM_LOCK_BITS_START);					uart_writeX(read_nvm_byte());					break;				case 'T':			// | Select device type                	| 'T' |    dd |      | 13d |   6  |					// read and ignore since we already know our					// device type.					uart_read_q(); 					uart_writeX('\r');					break;						case 's':			// | Read signature bytes              	| 's' |       | 3*dd |     |      |					if(get_signature()==TPI_OK){						uart_writeX(target_avr.signature[2]);						uart_writeX(target_avr.signature[1]);						uart_writeX(target_avr.signature[0]);					}#if LCD_4BIT == YES					fprintf_P(&lcd_stream, PSTR("\n< sig  %02X%02X%02X"),						target_avr.signature[2],						target_avr.signature[1],						target_avr.signature[0]); #endif					break;						case 't':			// | Return supported device codes     	| 't' |       | n*dd | 00d |   7  |					// only give the one attached					if(get_signature()==TPI_OK){						uart_writeX(target_avr.device_code);						uart_writeX(0x00);					}					break;						case 'S':			// | Return software identifier        	| 'S' |       | s[7] |     |   8  |					uart_write_PSTR(PSTR(PROGRAMMER_ID));					break;						case 'V':			// | Return sofware version            	| 'V' |       |dd dd |     |   9  |					uart_write_PSTR(PSTR(SOFTWARE_VERSION));					break;						case 'v':			// | Return hardware version           	| 'v' |       |dd dd |     |   9  |					uart_write_PSTR(PSTR(HARDWARE_VERSION));					break;				case'p':			// | Return programmer type            	| 'p' |       |   dd |     |  10  |					uart_writeX('S');					break;						case '.':			// | New universal command	       			| '.' |  4*dd |   dd | 13d |      |					// Used for non-blocked read/write memories					u_cmd = (uart_read_q()<<8) | uart_read_q();					switch(u_cmd){						case 0x5000: // read fuse							universal_read_fuse(CONF_BITS_START);							break;						case 0xACA8: // write fuse							uart_read_q();							fuse = uart_read_q();							universal_write_fuse(CONF_BITS_START, fuse);#if LCD_4BIT == YES							fprintf_P(&lcd_stream, PSTR("\n> fuse %02X"), fuse);#endif							break;						case 0x5800: // read lock							universal_read_fuse(NVM_LOCK_BITS_START);							break;						case 0xACE0: // write lock							uart_read_q();							lock = uart_read_q();							universal_write_fuse(NVM_LOCK_BITS_START, lock);#if LCD_4BIT == YES							fprintf_P(&lcd_stream, PSTR("\n> lock %02X"), lock);#endif							break;						case 0x3800: // read calibration							universal_read_fuse(CALIB_BITS_START);							break;						case 0x3000: // read signature							u_offset = uart_read_q();							uart_read_q();							write_nvm_address(DEV_ID_START + u_offset);							uart_writeX(read_nvm_byte());							uart_writeX('\r');							break;						default:							uart_writeX('?');							break;					}					break;				case 'E':			// | Exit bootloader		       					| 'E' |       |      | 13d |      |					// avrdude gives an error message if we don't do this					tpi_leave_programming_mode();					uart_writeX('\r');					break;				case 0x1B:			// | ESC - sync char	       					| x1B |   dd  |      |     |      |					// consume, no reply					break;				case 0xF0:			// UNO specific? Received when usb connected or port opened/closed					// consume, no reply					break;				default:			// | Unknown command	       						|     |       |      |  ?  |      |#if LCD_4BIT == YES					fprintf_P(&lcd_stream, PSTR("\n? %%%02X"), (uint8_t) command);#endif					uart_writeX('?');					break;			}		}		if(!in_programming_mode){													// only check button when inactive			msElapsed = msNow - msStamp;										// calc elapsed time			if(READ(BUTTON) == BUTTON_DOWN){								// button's down				if(debouncing == IDLE){												// if not debouncing					msStamp = msNow;														// time stamp					debouncing = PRESSED;												// and start debounce				} else {					if(debouncing == PRESSED){									// still debouncing						if(msElapsed > BOUNCE_PERIOD_MS){					// button's still down and debounce time elapsed							if(READ(READY_LED)){								INPUT(RESET_CAP);											// allow UNO DTR reset								CLEAR(RESET_CAP);																			CLEAR(READY_LED);							} else {								OUTPUT(RESET_CAP);										// override UNO DTR reset								SET(RESET_CAP);																				SET(READY_LED);							}							debouncing = WAIT;											// wait for button up						}					}				}			} else {																				// button's up				if(debouncing == WAIT){												// if not debouncing					msStamp = msNow;														// time stamp					debouncing = RELEASED;											// and start debounce				} else {					if(debouncing == RELEASED){									// still debouncing						if(msElapsed > BOUNCE_PERIOD_MS){					// button's still up and debounce time elapsed							debouncing = IDLE;											// wait for button down again							msNow = 0;															// reset time to prevent overflow						}					}				}			}		}	}}